---
title: "BDA - Project"
author: "Jan Nyberg, Carl-Victor Schauman"
date: 4/12/2022
output: 
  pdf_document: 
    toc: yes
    toc_depth: 1
urlcolor: blue
---
\newpage

```{r, include=FALSE}
#Provided code and imports
library("rstan")
library(matrixStats)
library(loo)
set.seed(23)
ham_data = read.csv("ham_data.csv", header=FALSE)
old_ham = read.csv("ham2015-2019.csv")
```

# Introduction

For this project, we are trying to predict Lewis Hamilton's average score in a season based on previous years scores. This is mostly just due to our curiosity if we are able to use this to somehow predict the score.   
We are modeling his scores from five years, and trying to build a model using it. We want to see what kind of distribution the answer will be and how well it is able to estimate the following year. There are many factors we don't take into consideration, but we hope to see relatively good results and predictions.

# Description of the data

The data we use is from Kaggle and can be found [here](https://www.kaggle.com/datasets/rohanrao/formula-1-world-championship-1950-2020). We took Lewis Hamilton out of the data and chose the years 2015-2019. We selected his scores from all the races from those years. One thing to note with the data is that every year doesn't have an equal amount of races. To account for this we chose to fill in the missing races with the median for the year. This makes the data a bit inaccurate, however, it shouldn't have too big an effect on the data.

```{r, echo=FALSE}

num_races = seq(1, 21, by=1)
l <- as.list(as.data.frame(t(old_ham)))
cum_sums <- list()
for (i in l) {
  cum_sums[length(cum_sums)+1] <- list(cumsum(i[3:23]))
}
#print(cum_sums[[1]])
plot(num_races, cum_sums[[1]], type="l", main="Hamilton cumulative points",
    xlab="Races", ylab="Points")

lines(cum_sums[[2]], col="red")
lines(cum_sums[[3]], col="blue")
lines(cum_sums[[4]], col="yellow")
lines(cum_sums[[5]], col="green")
legend(x=2, y=400, legend=c("2015", "2016", "2017", "2018", "2019"),
       col=c("black", "red", "blue", "yellow", "green"), lty=1, cex=0.8)
```

# Description of models


# Priors used



# Rstan code

```{stan, output.var="hier_ham"}
data {
  int<lower=0> N;
  int<lower=0> J;
  vector[J] y[N];
  real<lower=0> mu_s;
  real<lower=0> sigma_prior;
}

parameters {
  real<lower=0> mu;
  real<lower=0> sigma;
  real<lower=0> tau;
  vector[J] mus;
}

model {
  mu ~ normal(0, mu_s);
  tau ~ inv_chi_square(sigma_prior);
  sigma ~ inv_chi_square(tau);
  mus ~ normal(mu, tau);
  
  for (j in 1:J)
    y[,j] ~ normal(mus[j], sigma);
}

generated quantities {
  real ypred;
  real ypred_6;
  ypred = normal_rng(mus[5], sigma);
  ypred_6 = normal_rng(mu, sigma);
}
```

```{r}
hier_data = list(
  y = ham_data,
  N = nrow(ham_data),
  J = ncol(ham_data),
  mu_s = 20,
  sigma_prior = 5
)

hier_fit = sampling(
  hier_ham,
  data = ham_data,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  refresh = 0
)

```
```{r}
nrow(ham_data)
```


# Running of stan model

# Convergence diagnostics

# Posterior predictive checks

# Predictive performance assessment 

# Sensitivity analysis

# Model comparison

# Discussion of issues and potential improvements

# Conclusion what was learned from the data analysis

# Self-reflection